---
title: Java 并发编程实战笔记
categories: 
- Java
---

[TOC]

#### 一些概念

* 同步，异步
* 并发，并行
* 临界区:多个线程的公共资源
* 阻塞，非阻塞：
* 死锁:即A占有了B的资源，B占有了A的资源，两个线程都不能正常运行
* 饥饿:如某个高优先级线程一直抢占低优先级线程所需要的资源，使得低优先级线程不能正常运行
* 活锁：资源在两个线程之间不停跳动（两个线程都希望对方先使用资源），但没有一个线程拿到资源正常运行

#### 并发级别

1. 阻塞:一旦有一个线程占有临界区，其他线程只能等待该线程完成逻辑后释放临界区，是一种悲观的锁策略
2. 无饥饿:
3. 无障碍: 线程不会因为临界区被占据而挂起，一旦发现有资源冲突的问题则回滚相应操作
4. 无锁:一个线程可以在有限步数内完成
5. 无等待:所有线程都可以在有限步数内完成

#### JMM

1. **原子性**:一个操作是不可被中断的，即使多个线程一起运行的时候，一个操作一旦开始就不会被影响,**注意：**在32位jvm虚拟机上long和double变量的读写都不是原子性的，64位jvm虚拟机上也不一定是原子性的，需要看具体jvm虚拟机的内部实现，但是 volatile double 和volatile long的读写一定是原子性的                                             **参考https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7** 
2. **可见性**：当一个线程对共享资源进行了修改，其他线程能够马上知道这个修改
3. **有序性**：因为存在指令重排序，而指令重排只会保证单线程条件下的语义一致，所以多线程条件下要保证指令重排不会影响原有语义
4. **指令重排的原则**：

- **程序顺序原则**：单线程保证语义的串行性
- **volatile**原则：volatile变量的写一定是在读前面
- **锁规则**：解锁必定发生在之后的加锁之前
- **传递性**
- **线程start()方法在其所有操作之前**
- **线程所有操作先于线程终结之前**
- **对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生**
- **一个对象的初始化完成先行发生于他的finalize()方法的开始**

#### 线程的生命周期

如下图所示,**NEW**表示线程刚刚创建还没执行，当**start**()方法调用后才会执行，此时如果线程所需的资源都已经就绪就会进入**RUNNABLE**状态，如果执行的过程中遇到了**synchronized**同步块就会进入**BLOCKED**阻塞状态直到获得了锁。WAITING和TIMED_WAITING都表示线程处于等待状态，但是区别是前者是无时间限制的等待，后者是有时间限制的等待，通常因为**wait()**方法进入等待状态的线程是在等待**notify**()方法的执行，而因为**join()**方法进入等待的线程是在等待目标线程的中止，当等到了相应的事件线程会再次执行并进入**RUNNABLE**状态，当线程执行完毕后则会进入**TERMINATED**状态，表示结束。线程从**NEW**状态进入其他状态后不会再回到NEW状态，当然进入**TERMINATED**状态后也不会回到其他状态

![线程生命周期](/images/线程生命周期.png)

#### 线程的基本操作

